"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[375],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(7294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(t),m=s,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return t?a.createElement(h,o(o({ref:n},p),{},{components:t})):a.createElement(h,o({ref:n},p))}));function m(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var r=t.length,o=new Array(r);o[0]=d;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var c=2;c<r;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4109:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var a=t(7462),s=(t(7294),t(3905));const r={},o="\ud83d\udcab Stage & Scenes",i={unversionedId:"plugins/stage",id:"plugins/stage",title:"\ud83d\udcab Stage & Scenes",description:"In Opengram, scenes are a tool that allows you to control what happens in your bot, and",source:"@site/docs/plugins/stage.mdx",sourceDirName:"plugins",slug:"/plugins/stage",permalink:"/docs/plugins/stage",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/plugins/stage.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udcbe Sessions",permalink:"/docs/plugins/sessions"},next:{title:"\ud83c\udf10 Internalization (i18next)",permalink:"/docs/advanced/internalization"}},l={},c=[{value:"Scenes types / differences",id:"scenes-types--differences",level:2},{value:"How to use scenes",id:"how-to-use-scenes",level:2},{value:"Setup",id:"setup",level:3},{value:"BaseScene",id:"basescene",level:3},{value:"WizardScene",id:"wizardscene",level:3},{value:"Using scene with other plugins",id:"using-scene-with-other-plugins",level:2},{value:"Scenes options",id:"scenes-options",level:2},{value:"Important to remember when using scenes",id:"important-to-remember-when-using-scenes",level:2}],p={toc:c};function u(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"-stage--scenes"},"\ud83d\udcab Stage & Scenes"),(0,s.kt)("p",null,"In ",(0,s.kt)("strong",{parentName:"p"},"Opengram"),", scenes are a tool that allows you to control what happens in your bot, and\norganize commands and user messages in a structured way. This is especially useful when your bot\nworks with multiple commands or complex sequences of actions."),(0,s.kt)("p",null,"A typical use case for scenes is the sequential acceptance of input from the user."),(0,s.kt)("p",null,"Many beginners, when faced with the task of receiving data sequentially, try to do something like:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"bot.hears(..., ctx => {\n   bot.on('message', ...)\n})\n")),(0,s.kt)("p",null,"Which is ",(0,s.kt)("strong",{parentName:"p"},"fundamentally wrong"),", and most likely will not even work, but even if it does, it will lead to the appearance\nof new handlers in the chain, without the possibility of deleting them, and the subsequent ",(0,s.kt)("strong",{parentName:"p"},"memory leak")),(0,s.kt)("p",null,"The scene allows you to create separate handlers areas and move in and out of those areas."),(0,s.kt)("p",null,"When the user is in the scene, messages and other updates sent by telegram from the user get into the scene, where you\ncan process them and stop or continue processing."),(0,s.kt)("h2",{id:"scenes-types--differences"},"Scenes types / differences"),(0,s.kt)("p",null,"Scenes are divided into two types:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Wizard")," is a special type of scene that allows you to control the sequence of messages and actions in your bot.\nThey are very similar to regular scenes, but have some additional features that\nallow you to control the sequence of messages and actions."),(0,s.kt)("p",{parentName:"li"},"  For example, using the Scene Wizard, you can arrange to receive a sequence of messages that the user sends to the bot."),(0,s.kt)("p",{parentName:"li"},"  In the Wizard scene, the logic is divided into separate stages, between which you can switch by calling the\nappropriate methods, such as ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.wizard.next"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.wizard.back"),"."),(0,s.kt)("p",{parentName:"li"},"  Each stage can contain a group of handlers, for example, for the text and for the button")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Base")," scenes are a lighter abstraction that allows you to register a group of handlers that will be called when the\nuser is in the scene.\nThey can also be used to accept user input in sequence, but mostly for single questions."))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Base")," and ",(0,s.kt)("strong",{parentName:"p"},"Wizard")," scenes require specifying text identifier when created, to enter to them via\n",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.scene.enter('scene_name')")),(0,s.kt)("p",null,"Each of them has a separate session area to store data that is required as long as the scene is active:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ctx.scene.state")," - for ",(0,s.kt)("inlineCode",{parentName:"li"},"BaseScene")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ctx.wizard.state")," - for ",(0,s.kt)("inlineCode",{parentName:"li"},"WizardScene"))),(0,s.kt)("p",null,"The data in them will be available until user in the scene, ",(0,s.kt)("strong",{parentName:"p"},"after exiting they are destroyed"),"."),(0,s.kt)("p",null,"Scenes also have handlers that can be called before leave or when entering a scene."),(0,s.kt)("h2",{id:"how-to-use-scenes"},"How to use scenes"),(0,s.kt)("h3",{id:"setup"},"Setup"),(0,s.kt)("p",null,"The first thing to do before using it is to register sessions, since Stage uses them to store state and its data."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"For more details you can visit the ",(0,s.kt)("a",{parentName:"p",href:"/docs/plugins/sessions"},"session documentation"),", this part assumes you know what sessions are and how they work")),(0,s.kt)("p",null,"Once you've register the sessions, you can export the ",(0,s.kt)("inlineCode",{parentName:"p"},"Stage"),", instantiate it, and register scenes in ",(0,s.kt)("inlineCode",{parentName:"p"},"Stage"),"."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Stage middleware must be registered after the session."),(0,s.kt)("p",{parentName:"admonition"},"\u274c Wrong:"),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const stage = new Stage(...)\n\nbot.use(stage)\nbot.use(session())\n")),(0,s.kt)("p",{parentName:"admonition"},"\u2705 Good:"),(0,s.kt)("pre",{parentName:"admonition"},(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const stage = new Stage(...)\n\nbot.use(session())\nbot.use(stage)\n"))),(0,s.kt)("h3",{id:"basescene"},"BaseScene"),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const { Opengram, session, Stage, Scenes } = require('opengram')\n\nconst bot = new Opengram(process.env.BOT_TOKEN)\n\nbot.use(session())\n\n// Create BaseScene with id \"first\"\nconst firstScene = new Scenes.BaseScene('first')\n// Send \"Hi, how are you?\" when entering the scene\nfirstScene.enter(ctx => ctx.reply('Hi, how are you?'))\nfirstScene.on('text', async ctx => {\n  const { text } = ctx.message\n\n  ctx.scene.state = text // You can save the data for future responses, but this example does not use it.\n  await ctx.reply(`You say: ${text}`)\n\n  // Leave from scene\n  // Don't forget to await / return on ctx.scene.leave for bot.catch to work properly\n  await ctx.scene.leave()\n})\n// If received not text message, send \"Hmm it doesn't look like text. Try again :)\"\nfirstScene.use(ctx => ctx.reply(\"Hmm it doesn't look like text. Try again :)\"))\n// Send \"Bye, bye!\" when leave scene\nfirstScene.leave(ctx => ctx.reply('Bye, bye!'))\n\n// You can pass array of scenes to Stage constructor\n// or register using register method, for example:\n// const stage = new Stage()\n// stage.register(firstScene)\nconst stage = new Stage([firstScene])\nbot.use(stage)\n\n// Enter to \"first\" BaseScene when call /start command\n// Also you can pass initial state for ctx.wizard.state in second argument\n// Example: ctx.scene.enter('first', { propNameL: 'some value' })\nbot.start(ctx => ctx.scene.enter('first'))\n\nbot.launch()\n")),(0,s.kt)("h3",{id:"wizardscene"},"WizardScene"),(0,s.kt)("p",null,"Unlike the base scene, in the Wizard you can only filter update types using separate ",(0,s.kt)("inlineCode",{parentName:"p"},"Composer")," instances or manually,\nas the default handlers intercept all update types."),(0,s.kt)("p",null,"Example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const { Opengram, session, Stage, Scenes, Extra, Composer, Markup } = require('opengram')\n\nconst bot = new Opengram(process.env.BOT_TOKEN)\n\nbot.use(session())\n\n// Keyboard\nconst keyboard = Extra.markup(m => {\n  return m.inlineKeyboard(\n    [14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24].map(x => m.callbackButton(x, `years:${x}`)),\n    { columns: 3 }\n  )\n})\n\n// Create first step\nconst firstStep = new Composer()\nfirstStep.on('text', async ctx => {\n  const { text } = ctx.message\n  ctx.wizard.state.answers.push(text)\n  await ctx.reply(`You send ${text}. How old are you? (send number) Or select by button`, keyboard)\n  ctx.wizard.next()\n})\n\n// If received not text message, send \"Hmm it doesn't look like text. Try again :)\"\nfirstStep.use(ctx => ctx.reply(\"Hmm it doesn't look like number. Try again :)\", keyboard))\n\n\n// Create second step with text & buttons handlers\nconst secondStep = new Composer()\n\nsecondStep.on('text', async ctx => {\n  const { text } = ctx.message\n  const years = +text // Cast to number\n\n  // Validate\n  if (Number.isNaN(years)) {\n    return await ctx.reply('Wrong answer, please send number or select via buttons', keyboard)\n  }\n\n  ctx.wizard.state.answers.push(text)\n  await ctx.reply(`You are ${text} years old`)\n  // Leave from scene\n  // Don't forget to await / return on ctx.scene.leave for bot.catch to work properly\n  await ctx.scene.leave()\n})\n\nsecondStep.action(/^years:([0-9]{2})$/, async ctx => {\n  await ctx.answerCbQuery()\n  await ctx.editMessageReplyMarkup(Markup.inlineKeyboard([]))\n  const [,years] = ctx.match\n  ctx.wizard.state.answers.push(years)\n  await ctx.reply(`You are ${years} years old`)\n  // Leave from scene\n  // Don't forget to await / return on ctx.scene.leave for bot.catch to work properly\n  await ctx.scene.leave()\n})\n\n// Create WizardScene with id \"firstWizard\"\nconst firstScene = new Scenes.WizardScene('firstWizard', firstStep, secondStep)\n\n// Send \"Hi, how are you?\" when entering the scene\nfirstScene.enter(ctx => ctx.reply('Hi, how are you?'))\n\n// Send result answers list\nfirstScene.leave(async ctx => {\n  const answersList = ctx.wizard.state.answers\n    .map((answer, index) => `${index + 1}. ${answer}`)\n    .join('\\n')\n  await ctx.reply(`Answers:\\n${answersList}`)\n})\n\n// You can pass array of scenes to Stage constructor\n// or register using register method, for example:\n// const stage = new Stage()\n// stage.register(firstScene)\nconst stage = new Stage([firstScene])\nbot.use(stage)\n\n// Enter to \"firstWizard\" WizardScene when call /start command\n// Don't forget to await / return on ctx.scene.enter for bot.catch to work properly\n// Also you can pass initial state for ctx.wizard.state in second argument\nbot.start(ctx => ctx.scene.enter('firstWizard', { answers: [] }))\n\nbot.launch()\n")),(0,s.kt)("h2",{id:"using-scene-with-other-plugins"},"Using scene with other plugins"),(0,s.kt)("p",null,"If you want to use some plugins with scenes, just register them before Stage:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"bot.use(plugin1)\nbot.use(plugin2)\nbot.use(plugin3)\nbot.use(stage)\n")),(0,s.kt)("p",null,"Or you can register plugin only for specific scene like other handlers:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const scene = new Scenes.BaseScene(...)\n\nscene.use(plugin1)\nscene.use(plugin2)\nscene.use(plugin3)\n\n// ... other middlewares ...\n")),(0,s.kt)("p",null,"or for wizard:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const wizardScene = new WizardScene(..., step1, step2, step3)\n\n// This executed before wizard steps handlers\nwizardScene.use(plugin1)\nwizardScene.use(plugin2)\nwizardScene.use(plugin3)\n")),(0,s.kt)("h2",{id:"scenes-options"},"Scenes options"),(0,s.kt)("p",null,"You can specify ",(0,s.kt)("inlineCode",{parentName:"p"},"handlers"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"enterHandlers"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"leaveHandlers"),", and override ",(0,s.kt)("inlineCode",{parentName:"p"},"ttl")," (Time-to-live) for specific scene in\nsecond argument of ",(0,s.kt)("inlineCode",{parentName:"p"},"BaseScene")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"WizardScene"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"const base = new Scenes.BaseScene('first', {\n  handlers: [...], // Steps(s), optional\n  enterHandlers: [...], // Enter handler(s), optional\n  leaveHandlers: [...], // Enter handler(s), optional\n  ttl: 60 // TTL in seconds, optional\n})\n\nconst wizard = new Scenes.WizardScene('second', {\n  handlers: [...], // Steps(s), optional\n  enterHandlers: [...], // Enter handler(s), optional\n  leaveHandlers: [...], // Enter handler(s), optional\n  ttl: 60 // TTL in seconds, optional\n}, ...)\n")),(0,s.kt)("h2",{id:"important-to-remember-when-using-scenes"},"Important to remember when using scenes"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Always")," ",(0,s.kt)("inlineCode",{parentName:"p"},"return")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"await")," calls of ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.scene.enter(...)")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.scene.leave(...)"),"."),(0,s.kt)("p",{parentName:"li"},"When you call ",(0,s.kt)("inlineCode",{parentName:"p"},"enter")," / ",(0,s.kt)("inlineCode",{parentName:"p"},"leave"),", it calls ",(0,s.kt)("inlineCode",{parentName:"p"},"leave")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"enter")," scene handler and ",(0,s.kt)("strong",{parentName:"p"},"if some error trowed in them,\nyour bot can crash."))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Use ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.scene.state")," / ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.wizard.state")," instead of ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.session")," for data that is only needed in the scene.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Scenes metadata and state stored in the session, it means session state stored by ",(0,s.kt)("inlineCode",{parentName:"p"},"chat id + from id")," by default.\nFor every chat, user can be in a separated scene."),(0,s.kt)("p",{parentName:"li"},"If you need to change this behavior, you can change the session key generator, or create second ",(0,s.kt)("inlineCode",{parentName:"p"},"Stage"),"  + ",(0,s.kt)("inlineCode",{parentName:"p"},"session"),"\ninstances and define it for some middlewares chains.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Every handler just middleware and have ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx")," & ",(0,s.kt)("inlineCode",{parentName:"p"},"next")," arguments."),(0,s.kt)("p",{parentName:"li"},"If you call ",(0,s.kt)("inlineCode",{parentName:"p"},"next")," on a scene handler, the update will jump to the next matching scene handler, or failing that, it\nwill  go out of the scene scope and go to downstream middleware after ",(0,s.kt)("inlineCode",{parentName:"p"},"Stage"),". This also means that if no handler\ncatches the update, it will go out of the scene scope. To prevent this behavior in the examples above,\nyou can find lines like this:"),(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},'firstScene.use(ctx => ctx.reply("Hmm it doesn\'t look like text. Try again :)"))')),(0,s.kt)("p",{parentName:"li"},"This line intercepts all updates of the non-text type and displays a message.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"When you call ",(0,s.kt)("inlineCode",{parentName:"p"},"ctx.scene.enter")," and the user is currently in a scene, ",(0,s.kt)("inlineCode",{parentName:"p"},"leave")," is automatically called and after enters another scene"))))}u.isMDXComponent=!0}}]);